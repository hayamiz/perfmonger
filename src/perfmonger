#!/usr/bin/env ruby

require 'optparse'

module PerfMonger
module Command

class Runner
  def self.register_command(command_name, klass)
    @@commands ||= Hash.new
    @@commands[command_name] = klass
  end

  def initialize
    
  end

  def run(argv = ARGV)
    parser = OptionParser.new
    parser.banner = <<EOS
Usage: #{File.basename($0)} [options] COMMAND [args]

EOS

    parser.summary_indent = "  "

    parser.order!(argv)

    if argv.size == 0
      puts parser.help
      puts <<EOS

Commands:
#{@@commands.keys.sort.map{|sc| "  " + sc}.join("\n")}
EOS
      exit(false)
    end

    command_name = argv.shift
    command_class = @@commands[command_name]

    unless command_class
      puts "No such command: #{command_name}"
      puts <<EOS

Commands:
#{@@commands.keys.sort.map{|sc| "  " + sc}.join("\n")}
EOS
      exit(false)
    end

    command_class.new.run(argv)
  end
end

class Command
  class << self
    attr_accessor :command_name

    def register_command(command_name)
      Runner.register_command(command_name, self)
      self.command_name = command_name
    end
  end

  def initialize
    @parser = OptionParser.new
    @parser.banner = <<EOS
Usage: #{File.basename($0)} #{self.class.command_name} [options]

Options:
EOS
  end
end

class Record < Command
  register_command 'record'

  def initialize
    @devices           = []
    @interval          = 1.0
    @verbose           = false
    @report_cpu        = false
    @report_io         = false
    @report_ctx_switch = false

    @system_device_list = File.read("/proc/diskstats").each_line.map do |line|
      _, _, device = *line.strip.split
      device
    end

    super
  end

  def run(argv)
    @parser.on('-d', '--device DEVICE',
               'Device name to be observed (e.g. sda, sdb, md0, dm-1).') do |device|
      unless @system_device_list.include?(device)
        raise OptionParser::InvalidArgument.new("No such device: #{device}")
      end
      @devices.push(device)
      @report_io = true
    end

    @parser.on('-i', '--interval SEC',
               'Amount of time between each measurement report.') do |interval|
      @interval = Float(interval)
    end

    @parser.on('-C', '--cpu', 'Report CPU usage.') do
      @report_cpu = true
    end

    @parser.on('-S', '--context-switch', 'Report context switches per sec.') do
      @report_ctx_switch = true
    end

    @parser.on('-v', '--verbose') do
      @verbose = true
    end
    @parser.parse!(argv)

    if ! @report_io && ! @report_ctx_switch
      @report_cpu = true
    end

    exec_record_cmd()
  end

private
  def exec_record_cmd()
    cmd = File.expand_path("../perfmonger-record", __FILE__)

    args = []
    args << '-i'
    args << @interval.to_s
    args << '-C' if @report_cpu
    args << '-S' if @report_ctx_switch
    @devices.each do |device|
      args << '-d'
      args << device
    end
    args << 'v' if @verbose

    Process.exec(cmd, *args)
  end
end

class Plot < Command
  register_command 'plot'

  def run(argv)
    cmd = File.expand_path("../perfmonger-plot", __FILE__)
    Process.exec(cmd, *argv)
  end
end

end
end

if __FILE__ == $0
  PerfMonger::Command::Runner.new.run(ARGV)
end
