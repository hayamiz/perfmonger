#!/usr/bin/env ruby

require 'optparse'
require 'json'
require 'tempfile'

class PerfmongerPlot
  def initialize
    @parser = OptionParser.new
    @parser.banner = <<EOS
Usage: perfmonger plot [options] LOG_FILE

Options:
EOS

    @data_file = nil
    @offset_time = 0.0
    @output_dir = Dir.pwd
  end

  def parse_args(argv)
    @parser.on('--offset-time TIME') do |time|
      @offset_time = Float(time)
    end

    @parser.on('-o', '--output-dir DIR') do |dir|
      unless File.directory?(dir)
        puts("ERROR: no such directory: #{dir}")
        puts(@parser.help)
        exit(false)
      end

      @output_dir = dir
    end

    @parser.on('-T', '--output-type TYPE', 'Available: eps, png') do |typ|
      unless ['eps', 'png'].include?(typ)
        puts("ERROR: non supported image type: #{typ}")
        puts(@parser.help)
        exit(false)
      end

      @output_type = typ
    end

    @parser.parse!(argv)

    if argv.size == 0
      puts("ERROR: PerfMonger log file is required")
      puts(@parser.help)
      exit(false)
    end

    @data_file = argv.shift
  end

  def run(argv)
    parse_args(argv)

    plot_ioinfo()
    plot_cpuinfo()
  end

  private
  def plot_ioinfo()
    datafile = Tempfile.new("")
    gpfile = Tempfile.new("")

    start_time = nil
    devices = nil

    File.open(@data_file).each_line do |line|
      record = JSON.parse(line)
      time = record["time"]
      ioinfo = record["ioinfo"]
      return unless ioinfo

      start_time ||= time
      devices ||= ioinfo["devices"]

      datafile.puts([time - start_time,
                     devices.map{|device|
                       ioinfo[device]["r/s"]
                     }].flatten.map(&:to_s).join("\t"))
    end

    datafile.close

    col_idx = 2
    plot_stmt_list = devices.map do |device|
      plot_stmt = "\"#{datafile.path}\" usi 1:#{col_idx} with lines title \"#{device}\""
      col_idx += 1
      plot_stmt
    end

    eps_file = File.join(@output_dir, "read-iops.eps")
    gpfile.puts <<EOS
set term postscript enhanced color
set title "Read IOPS: #{@data_file}"
set output "#{eps_file}"

set xlabel "elapsed time [sec]"
set ylabel "IOPS"

set grid
set xrange [#{@offset_time}:*]
set yrange [0:*]

plot #{plot_stmt_list.join(",\\\n     ")}
EOS

    gpfile.close

    system("gnuplot #{gpfile.path}")

    if @output_type != 'eps'
      system("convert -rotate 90 -background white #{eps_file} #{eps_file.gsub(/\.eps$/, '.' + @output_type)}")
    end
  end

  def plot_cpuinfo()
    datafile = Tempfile.new("")
    gpfile = Tempfile.new("")

    start_time = nil
    devices = nil
    nr_cpu = nil

    File.open(@data_file).each_line do |line|
      record = JSON.parse(line)
      time = record["time"]
      cpuinfo = record["cpuinfo"]
      return unless cpuinfo
      nr_cpu = cpuinfo['nr_cpu']

      cores = cpuinfo['cpus']

      start_time ||= time

      datafile.puts([time - start_time,
                     %w|%usr %nice %sys %iowait %irq %soft %steal %guest %idle|.map do |key|
                       cores.map{|core| core[key]}.inject(&:+)
                     end].flatten.map(&:to_s).join("\t"))
    end

    datafile.close

    col_idx = 2
    columns = []
    plot_stmt_list = []
    %w|%usr %nice %sys %iowait %irq %soft %steal %guest|.each do |key|
      columns << col_idx
      plot_stmt = "\"#{datafile.path}\" usi 1:(#{columns.map{|i| "$#{i}"}.join("+")}) with filledcurve x1 lw 0 lc #{col_idx - 1} title \"#{key}\""
      plot_stmt_list << plot_stmt
      col_idx += 1
    end

    eps_file = File.join(@output_dir, "cpu.eps")
    gpfile.puts <<EOS
set term postscript enhanced color
set title "CPU usage: #{@data_file} (max: #{nr_cpu*100}%)"
set output "#{eps_file}"
set key outside center bottom horizontal

set xlabel "elapsed time [sec]"
set ylabel "CPU usage"

set grid
set xrange [#{@offset_time}:*]
set yrange [0:*]

plot #{plot_stmt_list.reverse.join(",\\\n     ")}
EOS

    gpfile.close
    system("gnuplot #{gpfile.path}")

    if @output_type != 'eps'
      system("convert -rotate 90 -background white #{eps_file} #{eps_file.gsub(/\.eps$/, '.' + @output_type)}")
    end
  end
end

def parse_args(argv)
  opt = Hash.new
  parser = OptionParser.new

  parser.banner = "Usage: #{$0} [options] LOGFILE"

  opt[:some_option] = 'default value'
  parser.on('-o', '--option VALUE') do |value|
    opt[:some_option] = value
  end

  opt[:offset_time] = 0.0
  parser.on('--offset-time VALUE') do |value|
    opt[:offset_time] = value.to_f
  end

  parser.parse!(argv)

  if argv.size != 1
    puts parser.banner
    exit false
  end

  opt[:logfile] = argv.first
  if ! File.exists?(opt[:logfile])
    $stderr.puts("ERROR: No such file: #{opt[:logfile]}")
    $stderr.puts parser.banner
    exit false
  end

  opt
end

def main(argv)
  opt = parse_args(argv)

  logfile = opt[:logfile]
end

if __FILE__ == $0
  PerfmongerPlot.new.run(ARGV.dup)
end
